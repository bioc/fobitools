
#' Classical Over Representation Analysis with FOBI
#'
#' @description This function performs a traditional Over Representation Analysis by hypergeometric test: classes are treated as sets of individual metabolites and all metabolites are treated as equally informative. This function uses Food-Biomarker Ontology knowledge as biological information.
#'
#' @param metaboliteList A vector of FOBI metabolite identifiers that define the selected list of metabolites. Other accepted identifiers are: HMDB, KEGG, PubChemCID, InChIKey, InChICode, and ChemSpider.
#' @param metaboliteUniverse A vector of FOBI metabolite identifiers that define the universe of possible metabolites. The identifiers should be of the same type as the `metaboliteList` identifiers.
#' @param subOntology A string specifying one of the two FOBI sub-ontologies: "food", or "biomarker".
#' @param pvalCutoff A numeric value indicating a p-value cutoff for p-values generated by the hypergeometric test.
#' @param adjust A string indicating a multiple testing method to use. Options are: "holm", "hochberg", "hommel", "bonferroni", "BH", "BY", and "fdr".
#' @param fobi FOBI table obtained with `parse_fobi()`. If this value is set to NULL, the last version of FOBI will be downloaded from GitHub.
#'
#' @export
#'
#' @return A tibble with ORA results.
#' @references Foroushani AB, Brinkman FS and Lynn DJ (2013). Pathway-GPS and SIGORA:identifying relevant pathways based on the over-representation of their gene-pair signatures. PeerJ, 1, pp. e229.
#' @references Pol Castellano-Escuder, Raúl González-Domínguez, David S Wishart, Cristina Andrés-Lacueva, Alex Sánchez-Pla, FOBI: an ontology to represent food intake data and associate it with metabolomic data, Database, Volume 2020, 2020, baaa033, https://doi.org/10.1093/databa/baaa033.
#' @author Pol Castellano-Escuder
#'
#' @examples
#' 
#' metaboliteUniverse <- c(fobitools::idmap$FOBI[1:200], fobitools::idmap$FOBI[400:450])
#' metaboliteList <- c(fobitools::idmap$FOBI[1:50], fobitools::idmap$FOBI[70:80])
#' 
#' # Food enrichment analysis
#' fobitools::ora(metaboliteList = metaboliteList, 
#'                metaboliteUniverse = metaboliteUniverse, 
#'                pvalCutoff = 1)
#' 
#' # Chemical class enrichment analysis
#' fobitools::ora(metaboliteList = metaboliteList, 
#'                metaboliteUniverse = metaboliteUniverse, 
#'                subOntology = "biomarker", 
#'                pvalCutoff = 1, adjust = "fdr")
#' 
#' @importFrom magrittr %>%
#' @importFrom tidyr unnest
#' @importFrom dplyr mutate select rename filter mutate_all rowwise pull arrange desc as_tibble
#' @importFrom stringr regex str_replace_all str_trim
#' @importFrom sigora makeGPS
ora <- function(metaboliteList,
                metaboliteUniverse,
                subOntology = "food",
                pvalCutoff = 0.01,
                adjust = "fdr",
                fobi = fobitools::fobi){

  if (is.null(metaboliteList)) {
    stop("metaboliteList must be a vector with selected metabolites")
  }
  if (!is.vector(metaboliteList)) {
    stop("metaboliteList must be a vector with selected metabolites")
  }
  if (is.null(metaboliteUniverse)) {
    stop("metaboliteUniverse must be a vector with the universe of possible metabolites")
  }
  if (!is.vector(metaboliteUniverse)) {
    stop("metaboliteUniverse must be a vector with the universe of possible metabolites")
  }
  if (!(subOntology %in% c("food", "biomarker"))) {
    stop("Incorrect value for subOntology argument. Options are 'food' and 'biomarker'")
  }
  if (pvalCutoff < 0) {
    stop("pvalCutoff cannot be less than zero")
  }
  if (!(adjust %in% c("holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr"))) {
    stop("Incorrect value for adjust argument")
  }

  ##

  if (is.null(fobi)){
    fobi <- parse_fobi()
  }
  
  ##
  
  idmap <- fobi %>%
    filter(!BiomarkerOf == "NULL") %>%
    select(name, FOBI, HMDB, KEGG, PubChemCID, InChIKey, InChICode, ChemSpider) %>%
    mutate_all(as.character) %>%
    mutate(HMDB = str_replace_all(HMDB, regex("( ).*"), regex("\\1")),
           KEGG = str_replace_all(KEGG, regex("( ).*"), regex("\\1")),
           PubChemCID = str_replace_all(PubChemCID, regex("( ).*"), regex("\\1")),
           ChemSpider = str_replace_all(ChemSpider, regex("( ).*"), regex("\\1"))) %>%
    rename(metaboliteNames = name) %>%
    mutate_all(~ ifelse(. == "NULL", NA, .)) %>%
    mutate_all(~ stringr::str_trim(.)) %>%
    filter(!duplicated(metaboliteNames))
  
  n_metaboliteUniverse <- length(unique(metaboliteUniverse[!is.na(metaboliteUniverse)]))
  
  universe_names <- idmap %>%
    rowwise() %>% 
    filter(any(c(FOBI, HMDB, KEGG, PubChemCID, InChIKey, InChICode, ChemSpider) %in% unique(metaboliteUniverse[!is.na(metaboliteUniverse)]))) %>%
    pull(metaboliteNames)
    
  ##

  GPSrepo_foods <- fobi %>%
    filter(!BiomarkerOf == "NULL") %>%
    select(id_BiomarkerOf, BiomarkerOf, name) %>%
    tidyr::unnest(cols = c(id_BiomarkerOf, BiomarkerOf, name)) %>%
    filter(name %in% universe_names) %>%
    mutate_all(as.factor)

  ##
  
  GPSrepo_chemicals <- fobi %>%
    filter(!BiomarkerOf == "NULL") %>%
    select(is_a_code, is_a_name, name) %>%
    tidyr::unnest(cols = c(is_a_code, is_a_name, name)) %>%
    filter(name %in% universe_names) %>%
    mutate_all(as.factor) %>%
    filter(!duplicated(.))

  ##

  n_food_metabolites <- GPSrepo_foods %>%
    filter(duplicated(id_BiomarkerOf))
  
  n_biomarker_metabolites <- GPSrepo_chemicals %>%
    filter(duplicated(is_a_code)) 
  
  if (subOntology == "food") {
    if(nrow(n_food_metabolites) > 1){
      GPSrepo <- sigora::makeGPS(GPSrepo_foods, maxFunperGene = 100, maxGenesperPathway = 500, minGenesperPathway = 1)
    }
    else {
      stop("At least two FOBI food classes must be represented by more than one compound in the metaboliteUniverse!")
    }
  }
  
  else if (subOntology == "biomarker") {
    if(nrow(n_biomarker_metabolites) > 1){
      GPSrepo <- sigora::makeGPS(GPSrepo_chemicals, maxFunperGene = 100, maxGenesperPathway = 500, minGenesperPathway = 1)
    }
    else {
      stop("At least two FOBI chemical classes must be represented by more than one compound in the metaboliteUniverse!")
    }
  }

  metaboliteList <- unique(metaboliteList[!is.na(metaboliteList)])
  n_metaboliteList <- length(metaboliteList)
  
  ## ORA

  fr <- GPSrepo$origRepo[[3]]
  sp1 <- GPSrepo$pathwaydescriptions

  if (length(intersect(metaboliteList, GPSrepo$origRepo[[2]])) == 0) {
    t1 <- which.max(sapply(idmap, function(x) length(intersect(x, GPSrepo$origRepo[[2]]))))
    t2 <- which.max(sapply(idmap, function(x) length(intersect(x, metaboliteList))))
    new_idmap <- idmap[, c(t2, t1)]
    colnames(new_idmap) <- c("match", "metaboliteName")
    metaboliteList <- new_idmap[which(new_idmap$match %in% metaboliteList), 2]
    message(paste0("\n", crayon::blue("Mapped identifiers from ", colnames(idmap)[t2], " to ", colnames(idmap)[t1])))
  }

  g1m <- match(metaboliteList$metaboliteName, GPSrepo$origRepo[[2]])
  frO <- fr[fr[, 2] %in% g1m ,]
  npwys <- table(as.character(GPSrepo$origRepo[[1]][(frO[,1])]))
  nn <- cbind(sp1[match(names(npwys), sp1$pwys), ], as.numeric(as.vector(npwys)))
  PPwys <- table(as.character(GPSrepo$origRepo[[1]][(fr[, 1])]))
  ps <- phyper(npwys - 1, PPwys[match(names(npwys), names(PPwys))],
               length(GPSrepo$origRepo[[2]]) - PPwys[match(names(npwys), names(PPwys))],
               length(intersect(metaboliteList$metaboliteName, GPSrepo$origRepo[[2]])), lower.tail = FALSE)

  result <- data.frame(nn, PPwys[match(names(npwys), names(PPwys))], as.numeric(ps),
                       as.numeric(p.adjust(ps, method = adjust))) %>%
    select(-4) %>%
    rename(classId = 1, className = 2, success = 3, classSize = 4, pvalue = 5, pvalueAdj = 6) %>%
    mutate(pvalue = round(pvalue, 4),
           pvalueAdj = round(pvalueAdj, 4)) %>%
    arrange(-desc(pvalue)) %>%
    filter(pvalue <= pvalCutoff) %>%
    as_tibble()

  message(paste0(crayon::blue("metaboliteUniverse size: ", n_metaboliteUniverse), 
                 "\n",
                 crayon::blue("metaboliteList size: ", n_metaboliteList)))
  
  return(result)
  
}

